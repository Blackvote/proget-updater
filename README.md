# Как это работает?

## Чтение конфигурационного файла `config.yml`

Программа начинает с чтения файла `config.yml`, который содержит все основные настройки для синхронизации пакетов. В конфигурационном файле определены следующие ключевые параметры:

### Параметры конфигурационного файла

- **syncChain**: Список цепочек синхронизации, каждая из которых описывает исходный и целевой серверы.
   - **URL**: Адреса исходного (`source.url`) и целевого (`destination.url`) серверов.
   - **API ключи**: Ключи для доступа к API обоих серверов (`source.apiKey` и `destination.apiKey`).
   - **Feed**: Идентификаторы фидов для серверов (`source.feed` и `destination.feed`).
   - **Type**: Тип пакетов, например, `nuget`, `upack` или `asset`.
   - **Таймауты**:
      - `timeout.webRequestTimeout`: Тайм-аут для веб-запросов.
      - `timeout.iterationTimeout`: Тайм-аут для итераций синхронизации.
      - `timeout.syncTimeout`: Тайм-аут для синхронизации.
      - `timeout.maxRetries`: Максимальное количество повторных попыток.

- **Ограничения на количество пакетов и версий**:
   - `proceedPackageLimit`: Максимальное количество пакетов, обрабатываемых за одну итерацию.
   - `proceedPackageVersion`: Максимальное количество версий каждого пакета для обработки.

- **Политики хранения (retention)**:
   - `enabled`: Включена ли политика хранения.
   - `dryRun`: Режим симуляции, когда изменения не применяются, но логируются.
   - `versionLimit`: Лимит на количество версий каждого пакета, которые должны быть сохранены на целевом сервере.

## Настройка логирования

- Если указан путь к файлу логов через аргумент `-l`, программа настраивает логирование таким образом, чтобы все записи выводились и в файл, и в консоль.
- Если путь не указан, логирование происходит только в консоль.
- В зависимости от флага `-debug`, устанавливается уровень логирования (более детализированный при включении режима отладки).

## Очистка директории пакетов

Программа очищает директорию, указанную в аргументе `-p`, где временно будут храниться загруженные пакеты. Удаляется всё содержимое директории для подготовки к новому циклу синхронизации, чтобы избежать накопления устаревших данных.

## Выполнение основной логики синхронизации

### Обработка цепочек синхронизации (`syncChain`)

Программа переходит к основному циклу, в котором обрабатываются цепочки синхронизации. Этот цикл повторяется до тех пор, пока не будет получен сигнал на завершение (например, `SIGTERM`).

### Загрузка списка пакетов с исходного сервера

Для каждой цепочки синхронизации отправляется GET-запрос на исходный сервер:

- URL запроса формируется как `syncChain.source.url/syncChain.Type/syncChain.source.feed/packages`.
- В запрос также добавляется заголовок с API ключом.
- Ответ от сервера содержит список пакетов, который парсится из JSON формата массив.

### Загрузка списка пакетов с целевого сервера

Аналогично исходному серверу, отправляется GET-запрос на целевой сервер:

- URL запроса формируется как `syncChain.destination.url/syncChain.Type/syncChain.destination.feed/packages`.
- В запрос также добавляется заголовок с API ключом.
- Ответ от сервера содержит список пакетов, который парсится из JSON формата массив.

### Сравнение списков пакетов с исходного и целевого серверов

Программа сравнивает полученные списки пакетов с исходного и целевого серверов:

- Определяется, какие пакеты и версии присутствуют на исходном сервере, но отсутствуют на целевом.
- Список пакетов, которые нужно синхронизировать, обрезается до максимального количества пакетов, определенного в `proceedPackageLimit`.
- Для каждого пакета ограничивается количество версий, которые будут синхронизированы, в соответствии с `proceedPackageVersion`.
- Если включена политика `retention`, пакеты, превышающие лимит версий (`retention.versionLimit`), будут помечены для пропуска при синхронизации.

### Синхронизация пакетов

Для каждой версии каждого пакета, который был определён для синхронизации, выполняются следующие шаги:

- **Скачивание пакета с исходного сервера**:
   - Отправляется GET-запрос на исходный сервер для скачивания конкретного пакета.
   - URL запроса формируется как `syncChain.source.url/syncChain.Type/syncChain.source.feed/download/group/name/version`.
   - Ответ (body) сохраняется в файл в директории пакетов с именем `name.version`.

- **Загрузка пакета на целевой сервер**:
   - Содержимое сохранённого файла считывается из директории пакетов.
   - Отправляется PUT-запрос на целевой сервер для загрузки содержимого файла.
   - URL запроса формируется как `syncChain.destination.url/syncChain.Type/syncChain.destination.feed/upload`.
   - Пакет загружается на целевой сервер.

### Сверка хэшей SHA-1

После загрузки пакета на целевой сервер программа проверяет, совпадает ли хэш SHA-1 пакета на целевом сервере с хэшем на исходном сервере.

- **Запрос хэша на исходном сервере**:
   - Отправляется запрос для получения SHA-1 хэша пакета с исходного сервера по адресу `syncChain.source.url/syncChain.Type/syncChain.source.feed/metadata/group/name/version`.

- **Запрос хэша на целевом сервере**:
   - Аналогичный запрос отправляется на целевой сервер по адресу `syncChain.destination.url/syncChain.Type/syncChain.destination.feed/metadata/group/name/version`.

- **Сравнение хэшей**:
   - Если хэши не совпадают, пакет на целевом сервере удаляется, и процесс загрузки повторяется.

- **Повторная попытка загрузки**:
   - Если хэши не совпали, программа предпринимает несколько попыток повторной загрузки и проверки хэшей до тех пор, пока хэши не совпадут или не будет исчерпано максимальное количество попыток (`maxRetries`).

## Retention (управление хранением)

После завершения синхронизации запрашивается обновленный список пакетов с целевого сервера (шаг 4.2).

- Программа проверяет, какие версии пакетов превышают лимит, заданный в `retention.versionLimit`.
- Для пакетов, которые превышают этот лимит, отправляются запросы на удаление:
   - Запросы формируются в зависимости от типа пакетов и отправляются на соответствующий URL, чтобы удалить старые версии.

Лимит бесплатной версии ProGet - 10 запросов на удаление в час

## Ожидание перед следующей итерацией

После завершения всех операций программа делает паузу на `iterationTimeout` секунд. Эта пауза необходима.

## Завершение работы

Основной цикл продолжается до тех пор, пока программа не получит сигнал на завершение (например, `SIGTERM` или `SIGINT`). При получении сигнала программа завершает текущую итерацию и корректно закрывает все открытые ресурсы, такие как файлы и сетевые соединения.

# Ключи запуска
```bash
  -c string
        path to config file (default "./config.yml")
  -l string
        path to logfile
  -p string
        path to save downloaded packages (default "./packages")
  --debug
        print some debug information
  --metrics 
        enable metric publish
```
## Метрики. 
Результаты всех http запросов.
Name: "updater_http_requests_total",
Help: "Total number of HTTP requests by one loop categorized by status code and HTTP method."

Общее кол-во успешно обработанных пакетов.
Name: "updater_package_proceed_total",
Help: "Total number of package successfully proceeded by one loop."

TODO: translate

